<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Many ways to run OpenShift on AWS | Partly Cloudy</title>
<meta name="generator" content="Jekyll v4.0.1" />
<meta property="og:title" content="Many ways to run OpenShift on AWS" />
<meta name="author" content="Josh Gavant" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="OpenShift is Kubernetes with batteries included and verified - that is, OpenShift is ready to run complex first- and third-party applications and digital workloads as soon as installation is complete. For example, every OpenShift cluster includes a software-defined network provider, a container and source build system and artifact registry, an Internet-facing router and even a system for maintaining and updating cluster components. Contrast this with a cluster provisioned by upstream kubeadm or even the more featureful kubespray, where adding these and other core, critical features requires thoughtful and sometimes fragile integration." />
<meta property="og:description" content="OpenShift is Kubernetes with batteries included and verified - that is, OpenShift is ready to run complex first- and third-party applications and digital workloads as soon as installation is complete. For example, every OpenShift cluster includes a software-defined network provider, a container and source build system and artifact registry, an Internet-facing router and even a system for maintaining and updating cluster components. Contrast this with a cluster provisioned by upstream kubeadm or even the more featureful kubespray, where adding these and other core, critical features requires thoughtful and sometimes fragile integration." />
<link rel="canonical" href="https://blog.joshgav.com//posts/openshift-on-aws" />
<meta property="og:url" content="https://blog.joshgav.com//posts/openshift-on-aws" />
<meta property="og:site_name" content="Partly Cloudy" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-08-09T07:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Many ways to run OpenShift on AWS" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Josh Gavant"},"dateModified":"2022-08-09T07:00:00+00:00","datePublished":"2022-08-09T07:00:00+00:00","description":"OpenShift is Kubernetes with batteries included and verified - that is, OpenShift is ready to run complex first- and third-party applications and digital workloads as soon as installation is complete. For example, every OpenShift cluster includes a software-defined network provider, a container and source build system and artifact registry, an Internet-facing router and even a system for maintaining and updating cluster components. Contrast this with a cluster provisioned by upstream kubeadm or even the more featureful kubespray, where adding these and other core, critical features requires thoughtful and sometimes fragile integration.","headline":"Many ways to run OpenShift on AWS","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.joshgav.com//posts/openshift-on-aws"},"url":"https://blog.joshgav.com//posts/openshift-on-aws"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://blog.joshgav.com//feed.xml" title="Partly Cloudy" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Partly Cloudy</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about">About author</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Many ways to run OpenShift on AWS</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2022-08-09T07:00:00+00:00" itemprop="datePublished">Aug 9, 2022
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>OpenShift is Kubernetes with batteries included and verified - that is,
OpenShift is ready to run complex first- and third-party applications and
digital workloads as soon as installation is complete. For example, every
OpenShift cluster includes a software-defined network provider, a container and
source build system and artifact registry, an Internet-facing router and even a
system for maintaining and updating cluster components. Contrast this with a
cluster provisioned by upstream
<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/">kubeadm</a>
or even the more featureful
<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubespray/">kubespray</a>,
where adding these and other core, critical features requires thoughtful and
sometimes fragile integration.</p>

<p>Not only does OpenShift offer a ready-to-use Kubernetes environment for
developers and operators once deployed, but also deployment itself has become
remarkably simple despite the many participants, especially when a cluster is
deployed in a public cloud provider like AWS. Gone are the days when operators
and infrastructure teams would have to pre-provision hardware and operating
systems and carefully configure and patch datacenter networks. Though it’s still
possible to customize OpenShift at deployment to your heart’s content, many use
cases can be met with defaults, a cloud provider account and a few well-written
commands.</p>

<p>In this article we’ll discuss three ways to deploy and run OpenShift on Amazon
Web Services (AWS) and we’ll contrast these with deploying upstream Kubernetes
with kubespray. The methods are presented in order of increasing complexity
and customizability.</p>

<p>Follow along with code at <a href="https://github.com/joshgav/openshift-on-aws.git">https://github.com/joshgav/openshift-on-aws.git</a>.</p>

<h2 id="contents">Contents</h2>

<ol>
  <li><a href="#rosa">Red Hat OpenShift Service on AWS (ROSA)</a></li>
  <li><a href="#ipi">OpenShift Installer-provisioned infrastructure</a></li>
  <li><a href="#upi">OpenShift User-provisioned infrastructure</a></li>
  <li><a href="#kubespray">Kubernetes with Kubespray</a></li>
</ol>

<p><a id="rosa"></a></p>

<h2 id="rosa-red-hat-openshift-service-on-aws">ROSA: Red Hat OpenShift Service on AWS</h2>

<blockquote>
  <p><a href="https://github.com/joshgav/openshift-on-aws/tree/main/rosa">Follow along</a>.</p>
</blockquote>

<p>Let’s start with the simplest option: Red Hat OpenShift Service on AWS, “ROSA”.
A ROSA cluster includes deployment, configuration <em>and</em> management of required
compute, network and storage resources in AWS as well as all the resources and
services of a OpenShift Kubernetes cluster. As opposed to other options to
follow, a ROSA environment is fully supported by Red Hat’s operations teams -
open a ticket and an expert Red Hat SRE will attend to it quickly.</p>

<h3 id="setup">Setup</h3>

<p>At the core of the ROSA lifecycle are the <a href="https://docs.openshift.com/rosa/rosa_cli/rosa-get-started-cli.html">rosa
CLI</a> tool
and the <a href="https://docs.openshift.com/rosa/ocm/ocm-overview.html">OpenShift Cluster
Manager</a> (OCM) service
(UI: <a href="https://console.redhat.com/openshift">https://console.redhat.com/openshift</a>).  Get the CLI from the
<a href="https://console.redhat.com/openshift/downloads">Downloads</a> section of the Red
Hat Console (free account required) or directly from
<a href="https://mirror.openshift.com/pub/openshift-v4/clients/rosa/latest/rosa-linux.tar.gz">https://mirror.openshift.com/pub/openshift-v4/clients/rosa/latest/rosa-linux.tar.gz</a>.
Source is at <a href="https://github.com/openshift/rosa">https://github.com/openshift/rosa</a>. The ROSA CLI invokes OCM
services as described at <a href="https://api.openshift.com/">https://api.openshift.com/</a>.</p>

<p>You’ll need both Red Hat and AWS credentials to enable the <code class="highlighter-rouge">rosa</code> CLI to
provision and connect to resources. Your AWS credentials can be specified as
exported <code class="highlighter-rouge">AWS_ACCESS_KEY_ID</code>, <code class="highlighter-rouge">AWS_SECRET_ACCESS_KEY</code> and <code class="highlighter-rouge">AWS_REGION</code>
environment variables as
<a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-envvars.html">for the AWS CLI</a>.</p>

<p>To get a token to login to your Red Hat account, click “View API token” at the
bottom of the Downloads page as shown in the following screenshot, or go
straight to <a href="https://console.redhat.com/openshift/token">the token page</a>. On
that page click “Load token”, then copy the raw token (not the <code class="highlighter-rouge">ocm</code> command
line) and run <code class="highlighter-rouge">rosa login --token="${your_token}"</code>. If successful you will see
this message (with your username of course): <code class="highlighter-rouge">"I: Logged in as 'joshgavant' on
'https://api.openshift.com'</code>.</p>

<p><img src="../assets/openshift_on_aws/console-downloads-token.png" width="300px" />
<img src="../assets/openshift_on_aws/ocm-manage-token.png" width="300px" /></p>

<blockquote>
  <p><strong>Tip</strong>: To quickly enable autocompletion for <code class="highlighter-rouge">rosa</code> commands in your current
  shell session run <code class="highlighter-rouge">. &lt;(rosa completion)</code>.</p>
</blockquote>

<p>To verify that you’ve logged in successfully to both accounts run <code class="highlighter-rouge">rosa whoami</code>.
If connections were successful you’ll see a list of attributes about each
account.</p>

<h3 id="iam-roles">IAM Roles</h3>

<p>Next you’ll need to create and link AWS IAM roles defining the limited permissions granted to the
cluster manager service and Red Hat operations team members. In the recommended “STS” mode,
these roles are applied to short-lived tokens issued to machine and human operators on demand.</p>

<p>The following commands grant required access to the OpenShift Cluster Manager
(OCM) and its installers. The last command creates roles for Installer,
ControlPlane, Worker and Support components to assume.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rosa create <span class="nt">--yes</span> ocm-role <span class="nt">--admin</span> <span class="nt">--mode</span><span class="o">=</span>auto <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"ManagedOpenShift"</span>
rosa create <span class="nt">--yes</span> user-role <span class="nt">--mode</span><span class="o">=</span>auto <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"ManagedOpenShift"</span>
rosa create <span class="nt">--yes</span> account-roles <span class="nt">--mode</span><span class="o">=</span>auto <span class="nt">--prefix</span><span class="o">=</span><span class="s2">"ManagedOpenShift"</span>
</code></pre></div></div>

<h3 id="create-cluster">Create cluster</h3>

<p>Now that you’ve bound your Red Hat account with your AWS account you can proceed
to create your ROSA cluster! Using the rosa CLI run the
following command to create a cluster in <a href="https://docs.openshift.com/rosa/rosa_getting_started/rosa-sts-getting-started-workflow.html">STS
mode</a>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## create a ROSA cluster in STS mode</span>
rosa create <span class="nt">--yes</span> cluster <span class="nt">--cluster-name</span> <span class="s2">"</span><span class="k">${</span><span class="nv">CLUSTER_NAME</span><span class="k">}</span><span class="s2">"</span> <span class="nt">--sts</span> <span class="nt">--mode</span><span class="o">=</span>auto <span class="nt">--watch</span>
</code></pre></div></div>

<p>You can also interactively provide configuration options at cluster creation
time by running only <code class="highlighter-rouge">rosa create cluster</code> and answering prompts. We’ll also
shortly describe how to create a cluster in OCM’s web pages.</p>

<h3 id="monitor-installation">Monitor installation</h3>

<p>By setting the <code class="highlighter-rouge">--watch</code> flag in the above command installation logs will stream
to stdout and the command won’t return till installation completes successfully
or fails, typically &gt;30 minutes. Start watching logs anytime with <code class="highlighter-rouge">rosa logs
install --cluster ${CLUSTER_NAME} --watch</code>.</p>

<p>You can also review your new cluster in the <a href="https://console.redhat.com/openshift">Red Hat
Console</a>. Click into it and expand the
“Show logs” section to reach a view like the following:</p>

<p><img src="../assets/openshift_on_aws/view-cluster-webui.png" width="300px" /></p>

<h3 id="use-cluster">Use cluster</h3>

<p>Once ready, the easiest way to begin using your cluster immediately is to
create a one-off <code class="highlighter-rouge">cluster-admin</code> user as follows. Later you can allow users from
a specific OpenIDConnect (OIDC) identity provider using <code class="highlighter-rouge">rosa create
oidc-provider ...</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## create a cluster-admin user</span>
rosa create <span class="nt">--yes</span> admin <span class="nt">--cluster</span> <span class="s2">"</span><span class="k">${</span><span class="nv">CLUSTER_NAME</span><span class="k">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>You’ll need URLs to reach the API server and Console of your new cluster and log
in; get those with <code class="highlighter-rouge">rosa list clusters</code>. Finally, log in to the cluster via the <code class="highlighter-rouge">oc</code>
CLI: <code class="highlighter-rouge">oc login --user cluster-admin --password ${admin_password}</code>.</p>

<h3 id="create-cluster-via-ui">Create cluster via UI</h3>

<p>Instead of using the <code class="highlighter-rouge">rosa</code> CLI, once your Red Hat and AWS accounts have been
linked as described above you can also choose to create a cluster via a guided
graphical wizard in the Console. On the <a href="https://console.redhat.com/openshift">Clusters page</a>
on the Red Hat Console click “Create cluster”, then on the <a href="https://console.redhat.com/openshift/create">Cluster create
page</a> click “Create cluster” next
to the ROSA offering, as in the following screenshot:</p>

<p><img src="../assets/openshift_on_aws/create-cluster-webui.png" width="300px" /></p>

<p>Your AWS account will be listed by its ID on the first page of the wizard.
Follow the prompts to configure and install a cluster.</p>

<p><a id="ipi"></a></p>

<h2 id="installer-provisioned-infrastructure-ipi">Installer-provisioned infrastructure (IPI)</h2>

<blockquote>
  <p><a href="https://github.com/joshgav/openshift-on-aws/tree/main/ipi">Follow along</a>.</p>
</blockquote>

<p>Even if your cluster won’t be managed by Red Hat you can provision and configure
cloud infrastructure and the cluster itself in AWS with a similar short list of
commands. Red Hat calls this installation method “Installer-provisioned
infrastructure” (IPI). Here’s how to do it.</p>

<h3 id="setup-1">Setup</h3>

<p>The core of the IPI method is the <strong><code class="highlighter-rouge">openshift-install</code></strong> CLI; download it from
the <a href="https://console.redhat.com/openshift/downloads#tool-x86_64-openshift-install">downloads section</a>
of the OpenShift console, or directly from
<a href="https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/stable/openshift-install-linux.tar.gz">https://mirror.openshift.com/pub/openshift-v4/x86_64/clients/ocp/stable/openshift-install-linux.tar.gz</a>. Source is at <a href="https://github.com/openshift/installer">https://github.com/openshift/installer</a>.</p>

<p>You’ll also need a <strong>pull secret</strong> containing credentials for Red Hat’s
container registries. Copy this from
<a href="https://console.redhat.com/openshift/downloads#tool-pull-secret">https://console.redhat.com/openshift/downloads#tool-pull-secret</a>.</p>

<p>A <strong>SSH key pair</strong> is required for access to provisioned machines; you’ll need
to provide its public key to the installer and you’ll be able to use the private
key for access. You can copy an existing key from (for example)
<code class="highlighter-rouge">~/.ssh/id_rsa.pub</code>; or create a new one in a secure place using (for example)
<code class="highlighter-rouge">ssh-keygen -t rsa -b 4096 -C "user@openshift" -f "${WORKDIR}/id_rsa" -N ''</code>.
Copy the contents of the <code class="highlighter-rouge">*.pub</code> file as the value of <code class="highlighter-rouge">SSH_PUBLIC_KEY</code> below.</p>

<p>Finally, you’ll need an AWS <strong>Route53 public hosted zone</strong> for your cluster’s
base domain name. For example, I delegate a domain named <code class="highlighter-rouge">aws.joshgav.com</code> from
my registrar to a new AWS Route53 zone, see following screenshot. Specifically,
after creating the Route53 zone I create NS records for <code class="highlighter-rouge">aws</code> in the parent
<code class="highlighter-rouge">joshgav.com</code> zone pointing to the name servers selected by Route53. More
details <a href="https://docs.openshift.com/container-platform/4.10/installing/installing_aws/installing-aws-account.html#installation-aws-route53_installing-aws-account">from RedHat
here</a>
and <a href="https://docs.aws.amazon.com/Route53/latest/DeveloperGuide/CreatingNewSubdomain.html">from AWS
here</a>.</p>

<p><img src="../assets/openshift_on_aws/aws-route53.png" width="300px" /></p>

<h3 id="create-cluster-1">Create cluster</h3>

<p>Now you can use <code class="highlighter-rouge">openshift-install create ...</code> to independently manage various
phases of the installation process. A simple, automatable approach is to define
the desired state of your cluster in a file named <code class="highlighter-rouge">install-config.yaml</code> put it
in a directory <code class="highlighter-rouge">${WORKDIR}</code> and run the installer with it as follows:
<code class="highlighter-rouge">openshift-install create cluster --dir ${WORKDIR}</code>. Following is a template
install-config.yaml file; use it with your own values for
<code class="highlighter-rouge">OPENSHIFT_PULL_SECRET</code>, <code class="highlighter-rouge">YOUR_DOMAIN_NAME</code> and <code class="highlighter-rouge">SSH_PUBLIC_KEY</code> established
above.</p>

<blockquote>
  <p>NOTE: The schema for install-config is in <a href="https://github.com/openshift/installer/blob/master/pkg/types/installconfig.go">https://github.com/openshift/installer/blob/master/pkg/types/installconfig.go</a>.</p>
</blockquote>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">apiVersion</span><span class="pi">:</span> <span class="s">v1</span>
<span class="na">metadata</span><span class="pi">:</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">ipi</span>
<span class="na">baseDomain</span><span class="pi">:</span> <span class="s">${YOUR_DOMAIN_NAME}</span>
<span class="na">controlPlane</span><span class="pi">:</span>
  <span class="na">architecture</span><span class="pi">:</span> <span class="s">amd64</span>
  <span class="na">hyperthreading</span><span class="pi">:</span> <span class="s">Enabled</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">master</span>
  <span class="na">platform</span><span class="pi">:</span> <span class="pi">{}</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
<span class="na">compute</span><span class="pi">:</span>
<span class="pi">-</span> <span class="na">architecture</span><span class="pi">:</span> <span class="s">amd64</span>
  <span class="na">hyperthreading</span><span class="pi">:</span> <span class="s">Enabled</span>
  <span class="na">name</span><span class="pi">:</span> <span class="s">worker</span>
  <span class="na">platform</span><span class="pi">:</span> <span class="pi">{}</span>
  <span class="na">replicas</span><span class="pi">:</span> <span class="m">3</span>
<span class="na">networking</span><span class="pi">:</span>
  <span class="na">networkType</span><span class="pi">:</span> <span class="s">OVNKubernetes</span>
  <span class="na">clusterNetwork</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">cidr</span><span class="pi">:</span> <span class="s">10.128.0.0/14</span>
    <span class="na">hostPrefix</span><span class="pi">:</span> <span class="m">23</span>
  <span class="na">machineNetwork</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="na">cidr</span><span class="pi">:</span> <span class="s">10.0.0.0/16</span>
  <span class="na">serviceNetwork</span><span class="pi">:</span>
  <span class="pi">-</span> <span class="s">172.30.0.0/16</span>
<span class="na">platform</span><span class="pi">:</span>
  <span class="na">aws</span><span class="pi">:</span>
    <span class="na">region</span><span class="pi">:</span> <span class="s">us-east-1</span>
<span class="na">publish</span><span class="pi">:</span> <span class="s">External</span>
<span class="na">pullSecret</span><span class="pi">:</span> <span class="s1">'</span><span class="s">${OPENSHIFT_PULL_SECRET}'</span>
<span class="na">sshKey</span><span class="pi">:</span> <span class="s1">'</span><span class="s">${SSH_PUBLIC_KEY}'</span>
</code></pre></div></div>

<h3 id="monitor-installation-1">Monitor installation</h3>

<p>Cluster installation will take 30 minutes or more. You can watch logs stream to
stdout or tail the <code class="highlighter-rouge">.openshift_install.log</code> file in the installation working
directory.</p>

<h3 id="use-cluster-1">Use cluster</h3>

<p>A username and password for your cluster will be in the final lines of the log,
either on stdout or in the <code class="highlighter-rouge">.openshift_install.log</code> file. In addition, a
“kubeconfig” file and the kubeadmin user’s password are saved in the <code class="highlighter-rouge">auth</code>
directory of the installation dir. Login to your cluster with one of the
following:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## using kubeconfig with embedded certificate</span>
<span class="nb">export </span><span class="nv">KUBECONFIG</span><span class="o">=</span>temp/_workdir/auth/kubeconfig

<span class="c">## using username and password</span>
oc login <span class="nt">--user</span> kubeadmin <span class="nt">--password</span> <span class="s2">"</span><span class="si">$(</span><span class="nb">cat </span>temp/_workdir/auth/kubeadmin-password<span class="si">)</span><span class="s2">"</span>

<span class="c">## verify authorization</span>
oc get pods <span class="nt">-A</span>
</code></pre></div></div>

<p><a id="upi"></a></p>

<h2 id="user-provisioned-infrastructure-upi">User-provisioned infrastructure (UPI)</h2>

<blockquote>
  <p><a href="https://github.com/joshgav/openshift-on-aws/tree/main/upi">Follow along</a>.</p>
</blockquote>

<p>Though the easiest way to get started with OpenShift on AWS is via ROSA or
installer-provisioned infrastructure (IPI), Red Hat also allows you to deploy
and configure your own cloud infrastructure - machines, networks and storage -
and provision a cluster over it. This is known as “user-provisioned
infrastructure” - UPI.</p>

<p>UPI installations still use the <code class="highlighter-rouge">openshift-install</code> CLI to generate resource
manifests and Ignition configuration files. However it is up to the user to
configure machines and supply these Ignition files to them. In AWS this is
accomplished by putting a configuration in a S3 bucket and pointing the first
machine there at startup.</p>

<p>Red Hat provides a set of CloudFormation templates reflecting good patterns for
provisioning supporting infrastructure for an OpenShift cluster; these templates
are available
<a href="https://github.com/openshift/installer/tree/master/upi/aws/cloudformation">here</a>.
In the <code class="highlighter-rouge">upi</code> directory in the repo which accomplanies this article a <code class="highlighter-rouge">deploy.sh</code>
script steps through the following:</p>

<ol>
  <li>Create manifests and configurations with <code class="highlighter-rouge">openshift-install</code></li>
  <li>Deploy AWS networks and machines using recommended CloudFormation templates</li>
  <li>Await completed installation using <code class="highlighter-rouge">openshift-install</code></li>
</ol>

<p>The AWS resources created for OpenShift include a VPC and subnets, a DNS zone
and records, load balancers and target groups, IAM roles, security groups and
even an S3 bucket. They also include several machine types - bootstrap, control
plane and worker. The bootstrap machine is provisioned first and installs the
production cluster on the other machines.</p>

<p>Full instructions for AWS UPI are <a href="https://docs.openshift.com/container-platform/4.10/installing/installing_aws/installing-aws-user-infra.html">here</a>.</p>

<p>Note that one step in the process can be difficult to automate - signing
Certificate Signing Requests (CSRs) for nodes. Check if CSRs are awaiting a
signature with <code class="highlighter-rouge">oc get csr</code>. Approve all pending requests with the following:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">csrs</span><span class="o">=(</span><span class="si">$(</span>oc get csr <span class="nt">-o</span> json | jq <span class="nt">-r</span> <span class="s1">'.items[] | select(.status == {}) | .metadata.name'</span><span class="si">)</span><span class="o">)</span>
<span class="k">for </span>csr <span class="k">in</span> <span class="s2">"</span><span class="k">${</span><span class="nv">csrs</span><span class="p">[@]</span><span class="k">}</span><span class="s2">"</span><span class="p">;</span> <span class="k">do
    </span>oc adm certificate approve <span class="s2">"</span><span class="k">${</span><span class="nv">csr</span><span class="k">}</span><span class="s2">"</span>
<span class="k">done</span>
</code></pre></div></div>

<p>As with IPI, you can monitor the <code class="highlighter-rouge">.openshift_install.log</code> file for progress of
cluster installation. When the cluster is ready, log in with <code class="highlighter-rouge">oc login</code> as the
kubeadmin user with the password in <code class="highlighter-rouge">${workdir}/auth/kubeadmin-password</code>, or set
your KUBECONFIG env var to the path <code class="highlighter-rouge">${workdir}/auth/kubeconfig</code>.</p>

<p>Once ready reach the console of your cluster at
<code class="highlighter-rouge">https://console-openshift-console.apps.${CLUSTER_NAME}.${BASE_DOMAIN}/</code>.</p>

<p><a id="kubespray"></a></p>

<h2 id="kubespray">Kubespray</h2>

<blockquote>
  <p><a href="https://github.com/joshgav/openshift-on-aws/tree/main/kubespray">Follow along</a>.</p>
</blockquote>

<p>The previous sections described how to deploy OpenShift, Red Hat’s Kubernetes
distribution, on Amazon Web Services with various levels of support and
automation. Next we’ll deploy upstream Kubernetes using
<a href="https://kubespray.io">Kubespray</a> in order to compare, contrast and gather new
ideas. Notably, kubespray’s included configuration for AWS infrastructure yields
an environment nearly identical to that produced by openshift-install.</p>

<blockquote>
  <p>Note: The most basic cluster installation tool is <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">kubeadm</a>, but it leaves
many critical aspects of the cluster incomplete, such as a network overlay,
container registry and load balancer controller. <a href="https://kubernetes.io/docs/setup/production-environment/tools/kubespray/">Kubespray</a> is also
maintained by the Kubernetes project and provides a more complete deployment.</p>
</blockquote>

<p>As with user-provisioned infrastructure (UPI) for OpenShift, with Kubespray the
user must first install infrastructure, then use Kubespray to install a cluster
on that infrastructure. Kubespray offers Terraform configurations for deploying
typical environments in cloud providers. For this example I used the
<a href="https://github.com/kubernetes-sigs/kubespray/tree/master/contrib/terraform/aws">configurations for
AWS</a>
which yields the following env:</p>

<p><img src="../assets/openshift_on_aws/aws-kubespray.png" width="300px" /></p>

<blockquote>
  <p>From <a href="https://github.com/kubernetes-sigs/kubespray/blob/master/contrib/terraform/aws/docs/aws_kubespray.png">https://github.com/kubernetes-sigs/kubespray/blob/master/contrib/terraform/aws/docs/aws_kubespray.png</a></p>
</blockquote>

<p>The infrastructure provisioning process finishes by creating an inventory file
which Ansible will consume to deploy cluster components. Now you’ll run the main
Kubespray process - an Ansible playbook - using that inventory:
<code class="highlighter-rouge">ansible-playbook -i hosts.ini cluster.yaml</code>. You can customize the deployment
by setting variables in the inventory vars files or by passing <code class="highlighter-rouge">-e key=value</code>
pairs to the ansible-playbook invocation. See <code class="highlighter-rouge">deploy-cluster.sh</code> in the
walkthrough for examples. So that you don’t have to install the Kubespray
Ansible environment locally, you may prefer to run commands like the following
in a container:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>podman run <span class="nt">--rm</span> <span class="nt">-it</span> <span class="se">\</span>
    <span class="nt">--mount</span> <span class="nb">type</span><span class="o">=</span><span class="nb">bind</span>,source<span class="o">=</span>kubespray/inventory/cluster,dst<span class="o">=</span>/inventory,relabel<span class="o">=</span>shared <span class="se">\</span>
    <span class="nt">--mount</span> <span class="nb">type</span><span class="o">=</span><span class="nb">bind</span>,source<span class="o">=</span>.ssh/id_rsa,dst<span class="o">=</span>/root/.ssh/id_rsa,relabel<span class="o">=</span>shared <span class="se">\</span>
        quay.io/kubespray/kubespray:v2.19.0 <span class="se">\</span>
            bash

<span class="c"># when prompted, enter (for example):</span>
ansible-playbook cluster.yml <span class="se">\</span>
    <span class="nt">-i</span> /inventory/hosts.ini <span class="se">\</span>
    <span class="nt">--private-key</span> /root/.ssh/id_rsa <span class="se">\</span>
    <span class="nt">--become</span> <span class="nt">--become-user</span><span class="o">=</span>root <span class="se">\</span>
    <span class="nt">-e</span> <span class="s2">"kube_version=v1.23.7"</span> <span class="se">\</span>
    <span class="nt">-e</span> <span class="s2">"ansible_user=ec2-user"</span> <span class="se">\</span>
    <span class="nt">-e</span> <span class="s2">"kubeconfig_localhost=true"</span>
</code></pre></div></div>

<p>By setting the variable <code class="highlighter-rouge">kubeconfig_localhost=true</code> a kubeconfig file with
credentials for the provisioned cluster will be written to the inventory
directory at the end of provisioning. It will use the internal IP address of an
API server; you’ll need to change this to the address of your
externally-accessible load balancer. Retrieve that with <code class="highlighter-rouge">aws elbv2
describe-load-balancers --output json | jq -r '.LoadBalancers[0].DNSName'</code>, and
be sure to prepend <code class="highlighter-rouge">https://</code> and append <code class="highlighter-rouge">:6443/</code> when putting it in the file.
Finally set your KUBECONFIG env var to point to that file and run <code class="highlighter-rouge">kubectl get
pods -A</code> to verify connectivity.</p>

<h2 id="conclusion">Conclusion</h2>

<p>In this article and <a href="https://github.com/joshgav/openshift-on-aws.git">accompanying
code</a> we’ve discussed and
demonstrated how to deploy an OpenShift or upstream Kubernetes cluster in AWS
using four different methods which progress from simplest to most complex: ROSA</p>
<blockquote>
  <p>IPI &gt; UPI &gt; Kubespray.</p>
</blockquote>

<p>To minimize the complexity and overhead of managing your own clouds and
clusters, start with the simplest method - ROSA - and progress to others only as
greater control and customization is needed.</p>

<p>Please provide feedback in <a href="https://github.com/joshgav/openshift-on-aws/">the
repo</a> or on
<a href="https://twitter.com/joshugav">Twitter</a>. Thank you!</p>

  </div><a class="u-url" href="/posts/openshift-on-aws" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Partly Cloudy</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Josh Gavant</li><li><a class="u-email" href="mailto:joshgavant@gmail.com">joshgavant@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/joshgav"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">joshgav</span></a></li><li><a href="https://www.twitter.com/joshugav"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">joshugav</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>A blog about cloud infrastructure and cloud-native application patterns and practices.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

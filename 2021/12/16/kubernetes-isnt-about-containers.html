<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" /><!-- Begin Jekyll SEO tag v2.7.1 -->
<meta name="generator" content="Jekyll v4.0.1" />
<meta property="og:title" content="Kubernetes isn’t about containers" />
<meta name="author" content="Josh Gavant" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Discussion of cloud-native patterns, practices and tools." />
<meta property="og:description" content="Discussion of cloud-native patterns, practices and tools." />
<link rel="canonical" href="https://joshgav.github.io/2021/12/16/kubernetes-isnt-about-containers.html" />
<meta property="og:url" content="https://joshgav.github.io/2021/12/16/kubernetes-isnt-about-containers.html" />
<meta property="og:site_name" content="Partly Cloudy" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-12-16T19:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Kubernetes isn’t about containers" />
<script type="application/ld+json">
{"description":"Discussion of cloud-native patterns, practices and tools.","author":{"@type":"Person","name":"Josh Gavant"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://joshgav.github.io/2021/12/16/kubernetes-isnt-about-containers.html"},"url":"https://joshgav.github.io/2021/12/16/kubernetes-isnt-about-containers.html","headline":"Kubernetes isn’t about containers","dateModified":"2021-12-16T19:00:00+00:00","datePublished":"2021-12-16T19:00:00+00:00","@type":"BlogPosting","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="https://joshgav.github.io/assets/css/main.css" />
  <link rel="shortcut icon" type="image/x-icon" href="/" />
  <link rel="stylesheet" href="https://joshgav.github.io/assets/css/agate.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.4.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad();
  </script><link type="application/atom+xml" rel="alternate" href="https://joshgav.github.io/feed.xml" title="Partly Cloudy" /></head><body>
    <main class="page-content" aria-label="Content">
        <div class="wrapper">
            <article
  class="post h-entry"
  itemscope
  itemtype="http://schema.org/BlogPosting"
>
  <head>
    <title>Kubernetes isn't about containers</title>
  </head>
  <header class="post-header">
    <div class="post-back">
      <a class="black-link" href="https://joshgav.github.io">
        ← Home
      </a>
    </div>

    <h1 class="post-title p-name" itemprop="name headline">
      Kubernetes isn&#39;t about containers
    </h1>
    <p class="post-meta">
      <time
        class="dt-published"
        datetime="2021-12-16T19:00:00+00:00"
        itemprop="datePublished"
      >Dec 16, 2021
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p><img src="/assets/always_has_been_apis.jpeg" alt="always has been APIs" /></p>

<p>It’s about APIs; we’ll get to that shortly.</p>

<h2 id="first-there-were-containers">First there were containers</h2>

<p>Now Docker <em>is</em> about containers: running complex software with a simple <code class="highlighter-rouge">docker run postgres</code> command was a revelation to software developers in 2013, unlocking agile infrastructure that they’d never known. And happily, as developers adopted containers as a standard build and run target, the industry realized that the same encapsulation fits nicely for workloads to be scheduled in compute clusters by orchestrators like Kubernetes and Apache Mesos. Containers have become the most important workload type managed by these schedulers, but as the title says that’s not what’s most valuable about Kubernetes.</p>

<p>Kubernetes is not about more general workload <a href="https://kubernetes.io/docs/concepts/scheduling-eviction/kube-scheduler/">scheduling</a> either (sorry <a href="https://krustlet.dev/">Krustlet</a> fans). While scheduling various workloads efficiently is an important value Kubernetes provides, it’s not the reason for its success.</p>

<h2 id="then-there-were-apis">Then there were APIs</h2>

<p>Rather, the attribute of Kubernetes that’s made it so successful and valuable is that <strong>it provides a set of standard programming interfaces for writing and using software-defined infrastructure services</strong>. Kubernetes provides specifications and implementations - a complete framework - for designing, implementing, operating and using infrastructure services of all shapes and sizes based on the same core structures and semantics: typed resources watched and reconciled by controllers.</p>

<p>To elaborate, consider what preceded Kubernetes: a hodge-podge of hosted “cloud” services with different APIs, descriptor formats, and semantic patterns. We’d piece together compute instances, block storage, virtual networks and object stores in one cloud; and in another we’d create the same using entirely different structures and APIs. Tools like Terraform came along and offered a common format across providers, but the original structures and semantics remained as variegated as ever - a Terraform descriptor targeting AWS stands no chance in Azure!</p>

<p>Now consider what Kubernetes provided from its earliest releases: standard APIs for describing compute requirements as pods and containers; virtual networking as services and eventually ingresses; persistent storage as volumes; and even workload identities as attestable service accounts. These formats and APIs work smoothly within Kubernetes distributions running everywhere, from public clouds to private datacenters. Internally, each provider maps the Kubernetes structures and semantics to that hodge-podge of native APIs mentioned in the previous paragraph.</p>

<p>Kubernetes offers a standard interface for managing software-defined infrastructure - <a href="https://joshgav.github.io/2021/09/30/cloud-redefined-infrastructure.html">cloud</a>, in other words. <strong>Kubernetes is a standard API framework for cloud services.</strong></p>

<h2 id="and-then-there-were-more-apis">And then there were more APIs</h2>

<p>Providing a fixed set of standard structures and semantics is the foundation of Kubernetes’ success. Following on this, its next act is to extend that structure to <em>any and all</em> infrastructure resources. <a href="https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/">Custom Resource Definitions</a> (CRDs) were introduced in version 1.7 to allow other types of services to reuse Kubernetes’ programming framework. CRDs make it possible to request not only predefined compute, storage and network services from the Kubernetes API, but also databases, task runners, message buses, digital certificates, and whatever else a provider can imagine!</p>

<p>As providers have sought to offer their services via the Kubernetes API as custom resources, the <a href="https://operatorframework.io/">Operator Framework</a> and related projects from <a href="https://github.com/kubernetes/community/tree/master/sig-api-machinery">SIG API Machinery</a> have emerged to provide tools and guidance that minimize work required and maximize standardization across all these shiny new resource types. Projects like <a href="https://crossplane.io">Crossplane</a> have formed to map other provider resources like RDS databases and SQS queues into the Kubernetes API just like network interfaces and disks are handled by core Kubernetes controllers today. And Kubernetes distributors like <a href="https://cloud.google.com/blog/topics/developers-practitioners/build-platform-krm-part-2-how-kubernetes-resource-model-works">Google</a> and <a href="https://docs.openshift.com/container-platform/4.9/operators/understanding/crds/crd-managing-resources-from-crds.html">Red Hat</a> are providing more and more custom resource types in their base Kubernetes distributions.</p>

<p>All of this isn’t to say that the Kubernetes API framework is perfect. Rather it’s to say that <em>it doesn’t matter</em> (much) because the Kubernetes model has become a de facto standard. Many developers understand it, many tools speak it, and many providers use it. Even with warts, Kubernetes’ broad adoption, user awareness and interoperability mostly outweigh other considerations.</p>

<p>With the spread of the Kubernetes resource model it’s already possible to describe an entire software-defined computing environment as a collection of Kubernetes resources. Like running a single artifact with <code class="highlighter-rouge">docker run ...</code>, distributed applications can be deployed and run with a simple <code class="highlighter-rouge">kubectl apply -f ...</code>. And unlike the custom formats and tools offered by individual cloud service providers, the Kubernetes’ descriptors are much more likely to run in many different provider and datacenter environments, because <strong>they all implement the same APIs</strong>.</p>

<p>Kubernetes isn’t about containers after all. It’s about APIs.</p>


  </div>

  <a class="u-url" href="/2021/12/16/kubernetes-isnt-about-containers.html" hidden></a>
</article>

        </div>
    </main><footer class="site-footer h-card">
    <data class="u-url" href="/"></data>
    <div class="wrapper">
      <div class="footer-col-wrapper">
        <div class="footer-col">
          <ul class="contact-list">
            <li class="p-name"><a class="black-link" href="https://joshgav.github.io/about.html">
                  Josh Gavant 
                </a></li><li>
              <a class="u-email black-link" href="mailto:joshgavant@gmail.com">joshgavant@gmail.com</a></li></ul>
        </div>
      </div>
    </div>
  </footer></body>
</html>